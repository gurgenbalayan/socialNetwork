# generated by fastapi-codegen:
#   filename:  openapi.json
#   timestamp: 2024-03-23T12:29:33+00:00

from __future__ import annotations

from typing import List, Union
from fastapi import FastAPI, HTTPException,Depends
from pydantic import confloat
from auth_bearer import JWTBearer
import uuid

import db.redis_tools
from models import *
from db.db import add_user, authenticate_user, get_user_by_id
from utils.hashing import Hasher
from utils.security import create_access_token
from datetime import timedelta
from db.redis_tools import RedisTools
from config import load_config

app = FastAPI(
    title='OTUS Highload Architect',
    version='1.2.0',
)


@app.get(
    '/dialog/{user_id}/list',
    response_model=List[DialogMessage],
    responses={
        '500': {'model': DialogUserIdListGetResponse},
        '503': {'model': DialogUserIdListGetResponse1},
    },
)
def get_dialog_user_id_list(
    user_id: str,
) -> Union[
    List[DialogMessage], DialogUserIdListGetResponse, DialogUserIdListGetResponse1
]:
    pass


@app.post(
    '/dialog/{user_id}/send',
    response_model=None,
    responses={
        '500': {'model': DialogUserIdSendPostResponse},
        '503': {'model': DialogUserIdSendPostResponse1},
    },
)
def post_dialog_user_id_send(
    user_id: str, body: DialogUserIdSendPostRequest = None
) -> Union[None, DialogUserIdSendPostResponse, DialogUserIdSendPostResponse1]:
    pass


@app.put(
    '/friend/delete/{user_id}',
    response_model=None,
    responses={
        '500': {'model': FriendDeleteUserIdPutResponse},
        '503': {'model': FriendDeleteUserIdPutResponse1},
    },
)
def put_friend_delete_user_id(
    user_id: str,
) -> Union[None, FriendDeleteUserIdPutResponse, FriendDeleteUserIdPutResponse1]:
    pass


@app.put(
    '/friend/set/{user_id}',
    response_model=None,
    responses={
        '500': {'model': FriendSetUserIdPutResponse},
        '503': {'model': FriendSetUserIdPutResponse1},
    },
)
def put_friend_set_user_id(
    user_id: str,
) -> Union[None, FriendSetUserIdPutResponse, FriendSetUserIdPutResponse1]:
    pass


@app.post(
    '/login',
    response_model=LoginPostResponse,
    responses={
        '500': {'model': LoginPostResponse1},
        '503': {'model': LoginPostResponse2},
    },
)
def post_login(
    body: LoginPostRequest,
) -> Union[LoginPostResponse, LoginPostResponse1, LoginPostResponse2]:
    password = body.password
    user_id = body.user_id
    pass_hash = authenticate_user(user_id)
    if not pass_hash:
        raise HTTPException(status_code=401, detail='Incorrect username or password')
    elif Hasher.verify_password(plain_password=password, hashed_password=pass_hash):
        if user_id in RedisTools.get_keys():
            return LoginPostResponse(token=RedisTools.get_value(user_id))
        cfg_token = load_config(section='token')
        access_token_expires = timedelta(minutes=int(cfg_token['access_token_expire_min']))
        access_token = create_access_token(data={'sub': user_id}, expires_delta=access_token_expires)
        RedisTools.set_key(key=user_id, value=access_token)
        return LoginPostResponse(token=access_token)
    else:
        raise HTTPException(status_code=401, detail='Incorrect username or password')




@app.post(
    '/post/create',
    response_model=str,
    responses={
        '500': {'model': PostCreatePostResponse},
        '503': {'model': PostCreatePostResponse1},
    },
)
def post_post_create(
    body: PostCreatePostRequest = None,
) -> Union[str, PostCreatePostResponse, PostCreatePostResponse1]:
    pass


@app.put(
    '/post/delete/{id}',
    response_model=None,
    responses={
        '500': {'model': PostDeleteIdPutResponse},
        '503': {'model': PostDeleteIdPutResponse1},
    },
)
def put_post_delete_id(
    id: str,
) -> Union[None, PostDeleteIdPutResponse, PostDeleteIdPutResponse1]:
    pass


@app.get(
    '/post/feed',
    response_model=List[Post],
    responses={
        '500': {'model': PostFeedGetResponse},
        '503': {'model': PostFeedGetResponse1},
    },
)
def get_post_feed(
    offset: Optional[confloat(ge=0.0)] = 0, limit: Optional[confloat(ge=1.0)] = 10
) -> Union[List[Post], PostFeedGetResponse, PostFeedGetResponse1]:
    pass


@app.get(
    '/post/get/{id}',
    response_model=Post,
    responses={
        '500': {'model': PostGetIdGetResponse},
        '503': {'model': PostGetIdGetResponse1},
    },
)
def get_post_get_id(
    id: str,
) -> Union[Post, PostGetIdGetResponse, PostGetIdGetResponse1]:
    pass


@app.put(
    '/post/update',
    response_model=None,
    responses={
        '500': {'model': PostUpdatePutResponse},
        '503': {'model': PostUpdatePutResponse1},
    },
)
def put_post_update(
    body: PostUpdatePutRequest = None,
) -> Union[None, PostUpdatePutResponse, PostUpdatePutResponse1]:
    pass


@app.get(
    '/user/get/{id}', dependencies=[Depends(JWTBearer())],
    response_model=User,
    responses={
        '500': {'model': UserGetIdGetResponse},
        '503': {'model': UserGetIdGetResponse1},
    },
)
def get_user_get_id(
    user_id: str,
) -> Union[User, UserGetIdGetResponse, UserGetIdGetResponse1]:
    data = get_user_by_id(user_id)
    if data:
        model={'user_id': data[0], 'first_name': data[1], 'second_name': data[2], 'birthdate': data[3], 'biography': data[4], 'city': data[5]}
        return model
    else:
        raise HTTPException(status_code=404, detail='Page not found')


@app.post(
    '/user/register',
    response_model=UserRegisterPostResponse,
    responses={
        '500': {'model': UserRegisterPostResponse1},
        '503': {'model': UserRegisterPostResponse2},
    },
)
def post_user_register(
    body: UserRegisterPostRequest,
) -> Union[
    UserRegisterPostResponse, UserRegisterPostResponse1, UserRegisterPostResponse2
]:
    user_id = str(uuid.uuid4())
    add_user(user_id, body.first_name, body.second_name, body.birthdate, body.biography, body.city, Hasher.get_password_hash(body.password))

    return UserRegisterPostResponse(user_id=user_id)

@app.get(
    '/user/search',
    response_model=List[User],
    responses={
        '500': {'model': UserSearchGetResponse},
        '503': {'model': UserSearchGetResponse1},
    },
)
def get_user_search(
    first_name: str, last_name: str = ...
) -> Union[List[User], UserSearchGetResponse, UserSearchGetResponse1]:
    pass
